# 类与对象

## 类之间的关系

在类之间， 最常见的关系有  

- 依赖（“ **uses**-**a**”） 

- 聚合（“ **has**-**a**”）  

- 继承（“ **is**-**a**”）

<br>

## 静态方法

静态方法（Static Method）是属于类而不是类的实例的方法。它可以在不创建类的实例的情况下被调用。静态方法通常用于执行与类相关的操作，而不需要访问或修改特定实例的状态。

### 与实例方法的区别

- 关联性：静态方法与类本身相关，而实例方法与类的实例相关。

- 调用方式：静态方法通过类名调用，而实例方法需要通过对象实例来调用。

- 访问权限：静态方法可以访问类的静态成员，但不能访问非静态成员（实例成员）。实例方法可以访问类的静态和非静态成员。

- 内部引用：静态方法中不能使用`this`关键字，因为它没有当前对象的引用。实例方法可以使用`this`来引用当前对象。

- 生命周期：静态方法在类加载时初始化，而实例方法在对象创建时初始化。

<br>

## 静态变量

静态变量，也称为类变量，是属于类而不是类的实例的变量。它在类加载时被初始化，只有一个副本，被所有类的实例共享。静态变量通常用于存储类级别的数据，它们不依赖于特定对象的状态，而是与整个类相关联。

### 生命周期

静态变量的生命周期与类的生命周期相同。它们在类加载时初始化，一直存在，直到程序结束或类被卸载。静态变量的值在类加载后保持不变，因为它们是类级别的，而不是与对象实例相关联。

### 作用域

静态变量在整个类中可见，它们的作用域覆盖整个类。可以在类的任何方法内部或外部访问静态变量。

总之，静态变量是属于类的，而不是类的实例的变量。它们在类加载时初始化，具有全局作用域，用于存储类级别的数据。静态变量通常用于存储不依赖于特定对象实例的信息，如常量值、计数器等。

<br>

## 静态块

静态初始化块是Java中的一种特殊的块，用于在类加载时执行静态初始化操作。静态初始化块通常用于执行一些与静态成员变量相关的初始化任务，或在类加载时执行一些必要的设置。

以下是关于静态初始化块的用途和如何使用它来初始化静态变量的信息：

### 用途

- 初始化静态变量：静态初始化块可以用于初始化静态变量，通常在静态变量的初始值不能直接赋值时使用。

- 执行复杂初始化逻辑：如果静态变量的初始化需要复杂的逻辑或依赖于其他类的加载，可以在静态初始化块中执行这些操作。

- 资源管理：静态初始化块可以用于管理资源，如数据库连接或文件句柄的初始化和释放。

<br>

## 静态内部类

静态内部类是嵌套在另一个类中的类，但它是一个静态类，与外部类的实例无关。静态内部类可以在不创建外部类实例的情况下被实例化，并可以访问外部类的静态成员，但不能访问外部类的非静态成员。

### 特点

- 它被声明为静态（使用`static`关键字）。
- 它不能访问外部类的非静态成员（即实例成员）。
- 它可以访问外部类的静态成员和方法。
- 静态内部类的实例化不依赖于外部类的实例。

### 用途

静态内部类常用于以下情况：

- 封装：将一组相关的类封装在一个类内部，以减少命名冲突，提高代码的组织性和可读性。

- 工厂模式：静态内部类可用于实现工厂模式，其中外部类充当工厂，而静态内部类提供工厂方法。

- 单例模式：静态内部类通常用于实现懒加载的单例模式，因为它在需要时才加载并初始化。

- 优化类结构：将一些与外部类不直接关联，但与其有某种联系的类组织在一起，以减少类的数量和提高代码可维护性。

<br>

## 继承下的加载顺序

1. 父类静态代码块、父类静态变量

2. 子类静态代码块、子类静态变量

3. 父类普通代码块、父类普通变量

4. 父类构造函数

5. 子类普通代码块、子类普通变量

6. 子类构造函数

## 参数传递

传递方式

- **值传递**是指在函数调用时，**将实际参数的值复制一份传递给形式参数**，在函数内对形式参数的修改不会影响到实际参数的值。这意味着函数内部对形参的改变不会影响到函数外部的变量。在值传递中，对形参的修改只作用于函数内部。
- **引用传递**是指在函数调用时，**将实际参数的引用或地址传递给形式参数**，函数内部对形参的修改会影响到实际参数。这意味着函数内部对形参的改变会影响到函数外部的变量。在引用传递中，对形参的修改会直接作用于函数外部的变量。

Java 总是采用按值调用，而非引用。

对于基本数据类型比较容易理解，例如

```java
int a = 1;
plusOne(a); // 数值加1
System.out.println(a); // 仍然输出1 
```

对于对象，传递的是对象引用的拷贝，参考：

```java
class Obj {
    private in val;

    Obj(int val) {
        this.val = val;
    }

    public void print() {
        System.out.println(val);
    }
}

public static void swap(Obj a, Obj b) {
    Obj temp = a;
    a = b;
    b = temp;
}

// 执行以下代码, 两个对象的val并没有被交换
// 因为swap方法的参数被初始化为两个对象引用的拷贝，方法交换的是这两个拷贝
Obj a = new Obj(1);
Obj b = new Obj(2);
swap(a, b);
a.print(); // 打印1
b.print(); // 打印2
plusOne(b);
b.print(); // 打印3
```

以上解释来自《Java核心技术 卷I 基础知识（原书第10版）》

那么为什么在方法中修改对象内的变量，在退出方法后，对象的变量值确实被改变了？一种解释是，虽然传递了对象引用的拷贝，但是这两个引用都指向堆上同一个对象的值。

## 重载与重写

### 重载

一个类中定义了多个方法，其方法名相同，但参数的数量不同，或数量相同而类型和次序不同。

两同：同一个类、方法名相同

三不同：参数个数、参数类型、参数顺序

- 被重载的方法必须改变参数列表(参数个数或类型不一样)；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。
- 无法以返回值类型作为重载函数的区分标准。

注意，不能通过返回类型区分，因为在调用目标方法时，是无法指定返回值类型信息的，这个时候编译器并不知道你要调用哪个函数

### 重写

在子类存在与父类方法的名字相同，参数的个数与类型一样，返回值也一样的方法。

- 参数列表与被重写方法的参数列表必须完全相同。
- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
- 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
- 父类的成员方法只能被它的子类重写。
- 声明为 final 的方法不能被重写。
- 声明为 static 的方法不能被重写，但是能够被再次声明。
- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
- 构造方法不能被重写。
- 如果不能继承一个类，则不能重写该类的方法。

<br>

参考

https://www.jb51.net/program/3228556ce.htm

https://blog.csdn.net/u014212540/article/details/131200745
