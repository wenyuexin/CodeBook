# 可伸缩性

可伸缩性：当增加计算资源时（例如CPU、内存、存储容量、IO宽带），程序的吞吐量或者处理能力相应地增加。其中，处理能力是指，在计算资源一定的情况下，能完成多少工作。

可伸缩性的调优，其目的是设法将问题的计算并行化，从而利用更多的计算资源来完成更多的任务。

**评价指标**

服务时间、响应时间、吞吐量

**Amdahl定律**

如果F 是必须串行化执行的比重，那么Amdahl定律告诉我们，在一个N 处理器的机器中，我们最多可以加速：

Speedup = 1/[F+(1-F)/N]

当处理器个数N趋近于无穷大时，加速比趋近于1/F。

### 多线程引入的开销

单线程不需要线程调度，不存在同步开销，不需要用锁来保证数据的一致性，但多线程有。因此，对于多线程而言，并行带来的性能提升必须大于并发导致的开销。

**上下文切换**

当可运行的线程大于CPU的数量，那么操作系统最终会将某个正在运行的线程调度出来，从而使其他线程能够使用CPU。这种调度将带来一次上下文切换。上下文是指某一时间点 CPU 寄存器和程序计数器的内容。

上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行以下的活动：（1）挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处，（2）在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复，（3）跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。

**内存同步**

这种开销包含多个方面。在synchronized和volatile提供的可见性保证中可能会使用一些特殊指令，也就是内存栅栏。这会抑制一些编译器优化。在内存栅栏中，大多数操作都不能重排。

内存同步可以分为竞争同步和非竞争同步。其中涉及虚拟机层面对synchronized的一些优化（逃逸分析、锁粗化等），详细内容这里就不细说了。

**阻塞**

多个线程在同一个锁上发生竞争时，竞争失败的线程会阻塞。

### 减少锁的竞争

在并发程序中，对可伸缩性影响最大的是独占方式的资源锁。

有两个影响在锁上发生竞争的可能性的因素：锁的请求频率和每次持有锁的时间。很明显，请求频率越低，每次持有的时间越短，则发生竞争的可能性越低。另外还可以使用带有协调机制的独占锁。

**缩小锁的范围**

尽可能的缩短锁的持有时间，例如可以将一些与锁无关的代码移除同步代码块之外，特别是开销很大的以及可能被阻塞的操作（比如IO操作）。当然，物极必反，同步代码块也不能过小，需要保证原子性的操作必须放在一个同步块内；其次，由于同步也需要一定开销，过分的拆分可能对性能产生负面的影响。

实际中当且可以将一些与同步无关计算量大的操作或则阻塞操作移除同步块时，才会考虑同步块大小问题。

**减小锁的粒度**

锁分解：如果一个锁需要保护多个互相独立的状态变量，那么可以将这个锁分解为多个锁，并且每个锁只保护一个变量。

锁分段：将锁进一步扩展为一组独立对象上的锁来保护。例如，并发容器`java.util.concurrent.ConcurrentHashMap`就使用分段锁，即将散列桶分为16组，各组由各自的锁进行保护。

**避免热点区域**

略

**替代独占锁的方案**

例如使用并发容器、读写锁、不可变对象、原子变量。。。