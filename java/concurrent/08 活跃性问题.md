# 活跃性问题

在编写多线程并发程序时，显而易见的是，我们需要保证线程的安全性，从而确保任何情况下都能正确的执行完任务。安全性和活跃性之间存在某种制衡，使用锁可以确保线程的安全性，但是过度的使用锁可能导致锁顺序死锁。使用线程池可以限制对资源的使用，但是被限制的行为可能导致资源死锁。

通俗地讲，活跃性就是希望程序能够顺利的执行完任务，不会因为无法获得某种资源从而导致任务进入永久等待。（个人总结，仅供参考）失去活跃性的进程表上面一直在执行，然而除非中止并重启，不然没有方法恢复。

<br>

活跃性问题主要涉及三种问题：死锁、饥饿、活锁。

## 死锁

**锁顺序死锁**：两个线程尝试以不同的顺序获得相同的锁。

例如，线程A持有锁L，并尝试获得锁R；同时，线程B持有锁R，并尝试获得锁L。此时，这两个线程将永久的等下去。如果所有线程都以固定的一致的顺序来获得锁，那么就不会出现锁顺序死锁。

**动态的锁顺序死锁**

有些方法看起来是以相同的顺序加锁，但实际上取决于该方法的外部调用。例如：

```
public void func(ClassA a, ClassB b, String[] args) {
	synchronized (a) {
		synchronnized (b) {
			doSomething();
		}
	}
}
```

表面上所有调用都是按先获得锁a再获得锁b的方式执行，然后是否发生死锁还取决于调用顺序，例如：

```
下面两行同时调用会导致死锁

func(a, b, args1)
func(b, a, args2)
```

如果上述两行同时执行，那么就会发生死锁。编写代码时应该注意是否存在嵌套的锁获取操作。避免该类死锁的方法可以用`System.identityHashCode`来定义锁的顺序，具体内容参考《Java并发编程实战》的10.1.2节。总之就是必须用某种方法限制获取锁的顺序。

**协作对象之间发生的死锁与开放调用**

这有点类似于上面的动态锁顺序死锁。假设A类有同步方法`fun1`和`fun2`，B类有同步方法`fun3`和`fun4`，同时A类和B类需要协作完成某种功能，导致`fun1`内部调用了`fun3`，而`fun4`内部调用了`fun2`，此时就可能产生死锁。

```
协作对象之间产生死锁的示例

class A {
	public synchronized void fun1 {
		...
		b.fun3(); //已经持有A的锁，并申请获得B的锁
		...
	}
	
	public synchronized void fun1 {
		...
	}
}

class B {
	public synchronized void fun3 {
		...
	}
	
	public synchronized void fun4 {
		...
		a.fun3(); //已经持有B的锁，并申请获得A的锁
		...
	}
}

> 如果fun1和fun4同时被调用，则会产生死锁
```

如果在调用某个方法时不需要持有锁，那么这种调用称为**开放调用**。简单来说，就是根据方法的具体内容，将对方法的锁变为方法内部的更为细粒度的锁。

**资源死锁**

正如当多个线程互相持有彼此正在等待的锁而又不释放自身已经持有的锁会引发死锁一样，多个线程在相同的资源上等待是也会发生死锁。

资源池通常采用信号量的形式实现当资源池为空时的阻塞行为。如果资源池里的资源不够就可能出现资源死锁。例如，线程A持有数据库`DB1`的锁并请求数据库`DB2`的锁，线程B持有数据库`DB2`的锁并请求数据库`DB1`的锁，如果两个数据库的资源都不够就会出现死锁。显然，当资源池越大，这种情况出现的概率就越小。

另一种资源死锁就是线程饥饿死锁。例如，对于`Executors.newSingleThreadExecutor()`返回的实例只能串行的执行接收的任务，因此如果一个正在执行的任务提交了另一个任务，就会因为资源不够而产生死锁，此时正在执行的任务将永久等待下去。总之，有界线程池/资源池与互相依赖的任务不能一起使用。

## 其他活跃性问题

**饥饿**

当线程无法访问它所需要的资源而不能继续执行时，就发生了饥饿。例如无法获得CPU时钟周期就可能导致该问题，具体的，如果不恰当使用了线程优先级可能会使优先级低的线程长期得不到CPU资源。

饥饿问题和资源死锁有些相似，个人认为，当线程无法获得某种资源从而导致一定时间内都无法执行，那就是饥饿。从执行逻辑来看，处于饥饿状态的线程也可能会重新获得资源然后继续执行。相较而言，处于资源死锁的线程将为了获得资源而长期等待下去，从这个意义来看处于资源死锁的线程也处于饥饿状态，但是资源死锁是永久性的。

**活锁**

产生活锁的原因是线程不断重复执行相同的操作，而且总会失败。该问题不会导致阻塞，但也不能继续执行下去。

例如，在某个消息处理机制中，某个消息不能成功处理，消息机制回滚整个事务并将该消息重新放到消息队列的头部，那么程序会因为反复执行反复失败而无法继续处理其他消息。简答来说，上述现象是因为将不可修复的错误作为可修复的错误，导致了恶性循环。

又如，当多个互相协作的线程对彼此进行响应从而修改自身状态，并使得任何一个线程都无法继续执行时，也存在活锁。这就像道路上两个互相礼让的行人不停的调整前进方向，结果每次都在另一个方向上堵住对方去路一样。解决这种现象的方法是在重试机制中引入某种随机性。