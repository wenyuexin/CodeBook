# 继承

继承是使用extends标记的 两个具有is-a关系的类。

java不支持多继承，但可以实现多个接口。final类不允许继承。

例子：

```java
// 超类、父类或基类
public class SuperClass {
    // 使用protected修饰, 允许子类通过super调用该方法
    protected SuperClass() {
    }

    // fun1只在SuperClass可访问
    private int fun1() {
        return 1;
    }

    public long fun2(int a) {
        return a + fun1();
    }

    public static double fun4() {
        return 4.0;
    }
}

// 子类、派生类
// 由于采用default修饰符, 其他的包无法使用SubClass
class SubClass extends SuperClass {
    public SubClass() {
        // 通过super实现对超类构造器的调用
        // 空参构造可写可不写, 子类默认调用空参构造器, 如果父类没有则会报错
        // 使用super调用构造器的语句必须是子类构造器的第一条语句
        super(); 
    }

    // 此处重写了父类的fun2方法
    @Override
    public long fun2(int a) {
        // 通过spuer关键字调用父类方法
        long b = super.fun2(a); 
        return b + 2L;
    }

    // fun3存在重载现象
    public int fun3(long a) {
        return (int) a + 3;
    }

    // 参数类型不同, 构成重载
    public int fun3(float a) {
        return (int) a + 3;
    }

    // 参数个数不同, 构成重载
    public int fun3(long a, int b) {
        return (int) a + (int) b + 3;
    }

    // 可以通过类名加方法名的方式访问静态方法
    public void fun5() {
        double result = fun4();
        System.out.println(result);
    }
}
```

## 修饰符与访问范围

| 修饰符       | 同一个类中 | 同一个包内 | 子类  | 全局  |
| --------- | ----- | ----- | --- | --- |
| public    | Yes   | Yes   | Yes | Yes |
| protected | Yes   | Yes   | Yes | No  |
| default   | Yes   | Yes   | No  | No  |
| private   | Yes   | No    | No  | No  |

## 重载与重写

### 重载

一个类中定义了多个方法，其方法名相同，但参数的数量不同，或数量相同而类型和次序不同。

两同：同一个类、方法名相同

三不同：参数个数、参数类型、参数顺序

- 被重载的方法必须改变参数列表(参数个数或类型不一样)；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。
- 无法以返回值类型作为重载函数的区分标准。

注意，不能通过返回类型区分，因为在调用目标方法时，是无法指定返回值类型信息的，这个时候编译器并不知道你要调用哪个函数

### 重写

重写或覆盖：在子类存在与父类方法的名字相同，参数的个数与类型一样，返回值也一样的方法。

- 参数列表与被重写方法的参数列表必须完全相同。
- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
- 被重写的方法的访问权限不能比父类中的方法更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
- 父类的成员方法只能被它的子类重写。
- 声明为 final 的方法不能被重写。
- 声明为 static 的方法不能被重写，但是能够被再次声明。
- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
- 构造方法不能被重写。
- 如果不能继承一个类，则不能重写该类的方法。
- 在覆盖一个方法的时候，子类方法不能低于超类方法的可见性

## 多态

多态(Polymorphism)允许同一个接口或方法在不同对象上具有不同的实现方式。

编译时多态（静态绑定）是指重载，运行时多态（动态绑定）是指重写。

## 继承下的加载顺序

1. 父类静态代码块、父类静态变量

2. 子类静态代码块、子类静态变量

3. 父类普通代码块、父类普通变量

4. 父类构造函数

5. 子类普通代码块、子类普通变量

6. 子类构造函数

## 接口和抽象类

**语法层面**

1）抽象类可以提供成员方法的实现细节，接口通常只有public abstract 方法；
2）抽象类中的成员变量可以是各种类型的，接口中的成员变量只能是public static final类型的；
3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。

**关于接口的default方法**

在java8以后，接口中可以添加使用default或者static修饰的方法。default修饰方法只能在接口中使用，在接口种被default标记的方法为普通方法，可以直接写方法体。

1）实现类会继承接口中的default方法

2）类同时实现了两个不同接口，但两个接口有相同的default方法时，该类必须重写接口中的default方法

3）如果子类继承父类，又实现了接口，那么当父类和接口同时实现同一方法（接口方法被default修饰）时，子类会继承父类的方法，而不是继承接口中的方法