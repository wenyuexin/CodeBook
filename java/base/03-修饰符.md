# Java修饰符

## 分类

Java语言提供了很多修饰符，大概分为两类： 

1. 访问权限修饰符 
2. 非访问权限修饰符

### 访问权限修饰符

**public**：共有访问。对所有的类都可见。  
**protected**：保护型访问。对同一个包可见，对不同的包的子类可见。  
**default**：默认访问权限。只对同一个包可见，注意对不同的包的子类不可见。  
**private**：私有访问。只对同一个类可见，其余都不见。  

| 修饰符       | 同类  | 同包  | 子类  | 其他包 |
|:---------:|:---:|:---:|:---:|:---:|
| public    | √   | √   | √   | √   |
| protected | √   | √   | √   | ×   |
| default   | √   | √   | ×   | ×   |
| private   | √   | ×   | ×   | ×   |

### 非访问权限修饰符

**static** 修饰符，用来创建类方法和类变量。  
**final** 修饰符，用来修饰类、方法和变量。被final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量不可修改。  
**abstract** 修饰符，用来创建抽象类和抽象方法。  
**synchronized** 用于多线程的同步。  
**volatile** 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。  
**transient**：序列化的对象包含被 transient 修饰的实例变量时，序列化和反序列化时会跳过该变量。  
<br>

## 类

### 外部类修饰符

**public**（访问控制符），将一个类声明为公共类，它可以被任何对象访问，一个程序的主类必须是公共类。  
**default**（访问控制符），类只对包内可见，包外不可见。  
**abstract**（非访问控制符），将一个类声明为抽象类，抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充，抽象类可以包含抽象方法和非抽象方法。  
**final**（非访问控制符），将一个类生命为最终（即非继承类），表示它不能被其他类继承。  

注意：  
1）protected 和 private 不能修饰外部类，是因为外部类放在包中，只有两种可能，包可见和包不可见。   
2） final 和 abstract不能同时修饰外部类，因为该类要么能被继承要么不能被继承，二者只能选其一。  
3）不能用static修饰，因为类加载后才会加载静态成员变量。所以不能用static修饰类和接口，因为类还没加载，无法使用static关键字。  

### 内部类修饰符

内部类与成员变量地位一直，所以可以public、protected、default和private，同时还可以用static修饰，表示嵌套内部类，不用实例化外部类，即可调用。

### 方法修饰符

**public**（公共控制符）：包外包内都可以调用该方法。  
**protected**（保护访问控制符）：指定该方法可以被它的类和子类进行访问。  
**default**(默认权限）：指定该方法只对同包可见，对不同包（含不同包的子类）不可见。  
**private**（私有控制符）：指定此方法只能有自己类等方法访问，其他的类不能访问（包括子类），非常严格的控制。  
**final**：指定方法已完备，不能再进行继承扩充。  
**static**：指定不需要实例化就可以激活的一个方法，即在内存中只有一份，通过类名即可调用。  
**synchronized**：同步修饰符，在多个线程中，该修饰符用于在运行前，对它所属的方法加锁，以防止其他线程的访问，运行结束后解锁。  
**native**：本地修饰符。指定此方法的方法体是用其他语言在程序外部编写的。  
**abstract**：抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾，例如：public abstract sample();。  

### 成员变量修饰符

**public**（公共访问控制符），指定该变量为公共的，它可以被任何对象的方法访问。  
**protected**（保护访问控制符）指定该变量可以别被自己的类和子类访问。在子类中可以覆盖此变量。  
**default**(默认权限），指定该变量只对同包可见，对不同包（含不同包的子类）不可见。  
**private**（私有访问控制符）指定该变量只允许自己的类的方法访问，其他任何类（包括子类）中的方法均不能访问。  
**static**（静态修饰符）指定变量被所有对象共享，即所有实例都可以使用该变量。变量属于这个类。   
**final**，最终修饰符，指定此变量的值不能变。final 和 static 经常一起使用来创建常量。   
**transient**（过度修饰符）指定该变量是系统保留，暂无特别作用的临时性变量。不持久化。  
**volatile**（易失修饰符）指定该变量可以同时被几个线程控制和修改，保证两个不同的线程总是看到某个成员变量的同一个值。   

### 局部变量修饰符

only final is permitted。   

为什么不能赋予权限修饰符？ 
因为局部变量的生命周期为一个方法的调用期间，所以没必要为其设置权限访问字段，既然你都能访问到这个方法，所以就没必要再为其方法内变量赋予访问权限，因为该变量在方法调用期间已经被加载进了虚拟机栈，换句话说就是肯定能被当前线程访问到，所以设置没意义。   

为什么不能用static修饰 
我们都知道静态变量在方法之前先加载的，所以如果在方法内设置静态变量，可想而知，方法都没加载，你能加载成功方法内的静态变量？
<br>

## 接口

### 接口修饰符

接口修饰符只能用public、default和abstract。不能用final、static修饰。默认修饰为abstract。

### 接口中方法修饰符

默认就是public abstract修饰。 
可以使用default定义默认方法，方法中提供实现，可以被继承和重写。

可以使用static定义静态方法，也能提供具体实现，不能被实现类重写，但可以在继承的子接口中直接定义同名方法。
<br>

## strictfp

 Java 中的一个关键字，表示FP-strict（strict floating-point, 浮点严格）。当你在一个`strictfp`修饰的类、接口或方法中时，所有的浮点表达式都会使用严格的IEEE 754浮点运算来计算。这意味代码在不同的硬件和软件平台上表现一致。由于这个关键字会限制处理器和编译器对浮点数运算的优化，因此很少使用。

该关键字适用于类或方法。父类标记后，子类不继承。

和BigDecimal的区别：

strictfp关注的是不同平台下结果的一致性而非精度，BigDecimal关注的是高精度的浮点数运算。strictfp性能比BigDecimal高。如果只有一致性要求，可以使用strictfp以提升性能。其次，BigDecimal的一致性完全取决于Java标准库的代码实现，理论上也能保证跨平台计算的一致性。

<br>

---------------------

**参考资料**  

- https://blog.csdn.net/dawn_after_dark/article/details/74527137 

- https://blog.csdn.net/white_pure/article/details/141287611
