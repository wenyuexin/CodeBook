# 类加载机制

类从被加载到虚拟机内存中，到卸载出内存为止，整个生命周期包括：

![img](https://images2015.cnblogs.com/blog/630246/201609/630246-20160919233012137-1305447753.png)

其中，验证（Verification）、准备（Preparation）和解析（Resolution）统称为连接（Linking）。

通常情况下类的加载必须按照上述步骤完成，但是解析阶段则不一定：某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称动态绑定）。

## 类加载的时机

虚拟机规范并没有明确何时开始执行类加载的第一个阶段（加载和类加载有所不同，加载是类加载的第一步），但是规定了**有且只有**以下5种情况出现时必须立即对类进行初始化（Initialization），而加载、验证、准备自然需要在此之前完成：

* 遇到`new`、`getstatic`、`putstatic`或`invokestatic`这四条字节码指令（注意，`newarray`指令触发的只是数组类型本身的初始化，而不会导致其相关类型的初始化，比如，`new String[]`只会直接触发`String[]`类的初始化，也就是触发对类`[Ljava.lang.String`的初始化，而直接不会触发String类的初始化）时，如果类没有进行过初始化，则需要先对其进行初始化。生成这四条指令的最常见的Java代码场景是：

  **1）**使用new关键字实例化对象的时候；

  **2）**读取或设置一个类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）的时候；

  **3）**调用一个类的静态方法的时候。

* 使用`java.lang.reflect`包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

* 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

* 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。

* 当使用`JDK 1.7`动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果`REF_getstatic`、`REF_putstatic`、`REF_invokeStatic`的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化

<br>

## 类加载的过程

### 加载

此阶段需要完成以下3件事情：

* 通过一个类的全限定名来获取该class文件的二进制字节流。（用户可以自定义类加载器）
* 将字节流的静态存储结构转化为方法区的运行时数据结构。
* 为上面的class文件，在堆中生成一个`java.lang.Class`对象对该类的数据访问入口

注：

数组类本身不通过类加载器创建，是由虚拟机直接创建。

### 验证

这个阶段主要是验证被加载的类是否正确。目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
流程：文件格式验证、元数据验证、字节码验证、符号引用验证

### 准备

该阶段就是正式**为类变量分配内存**并**设置类变量的初始值**，注意类变量使用的内存在方法区上分配。

类变量是static修饰的变量，不包括实例变量，实例变量将会在对象实例化的时候随着对象一起分配在Java堆上。而初始值通常是数据类型的零值。

### 解析

该阶段就是将jvm中常量池内的**符号引用**替换为**直接引用**的过程。

符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。

直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。

### 初始化

初始化是类加载的最后一步，简单说就是，执行类构造器`<clinit>()`方法的过程。

该方法由编译器自动收集类中的所有类变量的赋值动作和静态语句块（`static{}`块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定。静态语句块中只能访问到定义在静态语句块之前的类变量，定义在其之后的类变量，只能被赋值，不能被访问。

<br>

## 类加载器

类加载器是实现类加载过程中的“通过一个类的全限定名来获取此类的二进制字节流”的代码模块。

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在Java虚拟机的唯一性，每一个类加载器，都拥有一个独的类名称空间。

### 双亲委派模型

从虚拟机的角度看，只存在两种不同的类加载器：启动类加载器（由C++实现）以及其他。从程序开发人员的角度看，包括：启动类加载器、扩展类加载器、系统类加载器。

![img](https://images2015.cnblogs.com/blog/630246/201609/630246-20160919233328215-1000355433.png)

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。

双亲委派模型的工作过程是：

* 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。每个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。
* 每一个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。
* 只有当父加载器反馈自己无法完成这个加载请求时（搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。

<br>

---

**参考资料**

1. 《深入理解Java虚拟机：JVM高级特性与最佳实践》 周志明，机械工业出版社，第7章
2.  [JVM类生命周期概述：加载时机与加载过程 - Rico's Blogs - CSDN博客](https://blog.csdn.net/justloveyou_/article/details/72466105)