# 垃圾回收

垃圾回收涉及三个方面：哪些内存需要回收？什么时候回收？怎么回收？

## 1 垃圾标记方法

主要包括引用计数法和可达性分析算法。前者实现简单，判定效率高，但很难解决对象之间的互相循环引用的问题。因此主流的虚拟机实现中不会使用引用计数法。

可达性分析是一种基于图的方法，其基本思想是：通过一系列的称为`GC Roots`的对象作为起点，从这些节点开始向下搜索，搜索过的路径称为引用链，当一个对象没有任何与`GC Roots`相连的引用链时，则证明此对象是不可达的，因而被判定为可回收的对象。

Java中可以作为`GC Roots`的对象包括以下几种：

* 虚拟机栈中引用的对象
* 方法区中类静态字段引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI（即一般说的Native方法）引用的对象

<br>

## 2 垃圾收集算法

比较常见的算法有：标记-清除算法、复制算法、标记-整理算法、分代收集算法。

### 标记-清除（Mark-Sweep）

该算法包括两个阶段。首先标记出所有需要回收的对象，然后统一回收所有被标记的对象。

主要的问题：效率不高，容易产生大量不连续的内存碎片

### 复制（Copying）

将内存划分为两块，每次只使用其中一块。当一块内存用完了，将存活的对象复制到另一个块上面，然后把已使用过的内存空间一次性清理掉。

现在的商业虚拟机都使用这种方法来回收新生代。

### 标记-整理（Mark-Compact）

复制算法是基于大部分对象存活率低，朝生夕死的情况。如果存活率高，则会因为执行大量复制操作而导致效率变低。标记-整理算法适用于老年代，该方法和标记清除算法类似，区别在于不是标记后直接清除，而是先将存活对象移动到内存块的一端，然后将剩余部分的内存统一清理掉。

### 分代收集（Generational Collection）

主要思路是根据对象存活周期的不同将内存划分为几块。一般是把Java堆划分为新生代和老年代。新生代使用复制算法，老年代使用标记清除算法或者标记整理算法。

<br>

## 3 垃圾收集器

不同的虚拟机实现会有不同的垃圾收集器。以HotSpot虚拟机为例，主要有：

![img](https://images2017.cnblogs.com/blog/285952/201711/285952-20171109150752075-957670214.png)

**Serial收集器**：单线程收集器，收集时需要暂停其他所有线程的工作，直到收集结束

**ParNew收集器**：Serial收集器的多线程版本，复制算法，追求最短的回收停顿时间

**Parallel Scavenge收集器**：并行多线程收集器，复制算法，吞吐量（用户代码运行时间除以总时间）优先

**Serial收集器**：Serial收集器的老年代版本，标记-整理算法

**Parallel Old收集器**：Parallel Scavenge收集器的老年代版，多线程，标记-整理算法，吞吐量优先

**CMS收集器**：Concurrent Mark Sweep，标记-清除算法，并发收集，追求最短的回收停顿时间

**G1收集器**：并行，分代收集，整体上采用的标记整理算法，局部（连个region之间）基于复制算法，可预测的停顿

<br>

### CMS收集器

CMS是一种并发的基于标记-清除算法的收集器。其执行过程包含4个步骤：

**初始标记**：初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，但需要“Stop The World”。

**并发标记**：并发标记阶段就是进行GC Roots Tracing的过程，刚才产生的集合中标记出存活对象；应用程序也在运行；并不能保证可以标记出所有的存活对象；

**重新标记**：重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录；仍然需要需要”Stop The World“，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

**并发清除**：并发清除阶段会清除对象，回收所有的垃圾对象。

### G1收集器

G1（Garbage-First）是一款**面向服务端应用**的垃圾收集器，JDK 7 Update4 后开始进入商用。HotSpot开发团队赋予它的使命是未来可以替换掉JDK 1.5中发布的CMS收集器。

在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。

**G1收集器之所以能建立可预测的停顿时间模型**，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

与其他GC收集器相比，G1具备如下特点。

#### 特性

- **并行与并发**
G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。**
  
- **分代收集（收集范围包括新生代和老年代）**
与其他收集器一样，分代概念在G1中依然得以保留。G1可以不需要其他收集器配合就能独立管理整个GC堆，它能够采用不同的方式去处理不同时期的对象。使用G1收集器时，Java堆的内存布局有了很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。**

- **空间整合（结合多种垃圾收集算法，不产生碎片）**
与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。

- **可预测的停顿（低停顿的同时实现高吞吐量）**
这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

#### 应用场景

**1. 面向服务端应用，针对具有大内存、多处理器的机器**；**最主要的应用是为需要低GC延迟，并具有大堆的应用程序提供解决方案**；
如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；

**2. 用来替换掉JDK 1.5的CMS收集器；**
（1）超过50%的Java堆被活动数据占用；
（2）对象分配频率或年代提升频率变化很大；
（3）GC停顿时间过长（长与0.5至1秒）。

**3. 是否一定采用G1呢？也未必：**
   如果现在采用的收集器没有出现问题，不用着急去选择G1；如果应用程序追求低停顿，可以尝试选择G1；是否替代CMS需要实际场景测试才知道。

#### 执行步骤

G1收集器的运作大致可划分为以下几个步骤：

**初始标记（Initial Marking）**
初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。

**并发标记（Concurrent Marking）**
并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。

**最终标记（Final Marking）**
最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。

**筛选回收（Live Data Counting and Evacuation）**
筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分价值高的Region区的垃圾对象，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。回收时，采用“复制”算法，从一个或多个Region复制存活对象到堆上的另一个空的Region，并且在此过程中压缩和释放内存。





<br>

---

**参考资料**

1. 《深入理解Java虚拟机：JVM高级特性与最佳实践》 周志明，机械工业出版社，第3章

