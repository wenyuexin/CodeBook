# 线程安全与对象共享

**线程安全**：当多个线程访问某个类时，不管运行环境采用何种调度方式或者这些线程如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

<br>

**原子性**：一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

**可见性**：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改

**有序性**：程序执行结果和该程序在顺序一致性内存模型中的执行结果相同。

<br>

## volatile和synchronized

### volatile

volatile是比synchronized更轻量级的同步机制。关于volatile关键字，Java语言规范是这么写的，Java允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。如果一个字段被声明为volatile，那么Java线程内存模型将确保所有线程看到的这个变量的值是一致的，即保证了字段的可见性。

由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，仍需要通过加锁（使用synchronized或原子类）来保证原子性：

* 1）运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量值；
* 2）变量不需要与其他的状态变量共同参与不变约束。

第二点的语义是**禁止指令重排**。这是通过**内存屏障**（Memory Barrier或Memory Fence，指重排序时把后面的指令重排序到内存屏障之前的位置）实现的。在X86处理器下查看汇编代码可以发现多出了**lock前缀指令**。lock指令在多核处理器会引发两件事：

第一，将当前处理器缓存行的数据写回到系统内存；

第二，这个会写内存的操作会使其他CPU里缓存了该内存地址的数据无效。在多核处理器下，为了保证各个处理器的缓存是一致的，就会实现**缓存一致性协议**，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的数据是否过期，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器缓存的数据设置为无效状态，当处理器对这个数据进行修改操作时，就会重新从系统内存中吧数据读到处理器缓存里。

### synchronized

Java中的每一个对象都可以用作一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视锁（Monitor Lock）。具有以下3种方式：

* 对于普通同步方法，锁是当前的对象
* 对于静态同步方法，锁是当前的类
* 对于同步块方法，锁是synchronized括号里配置的对象

线程在进入同步代码块时会自动获取锁，并在退出时自动释放锁。Java的内置锁相当于一种互斥体（互斥锁），即某个时间点最多只有一个线程能持有锁。

**内置锁的可重入性**

Java的内置锁是**可重入**的，因此如果某个线程识图获得一个已经由它自己持有的锁，那么这个请求就会成功。这意味着内置锁的操作粒度是线程，而不是调用。重入的一种实现方法是为每个锁关联一个计数器和一个所有者线程。进入时计数器递增，退出时计数器递减，当计数器为0时锁被释放。

**synchronized的实现**

synchronized在虚拟机中是通过进入和退出Monitor对象来实现。在方法同步和代码块同步的实现在细节上略有不同。代码块同步是通过`monitorenter`和`monitorexit`指令实现，方法同步虽有区别，但也可以用这种方法实现。

`monitorenter`指令是在编译后插入到同步代码块的开始位置，而`monitorexit`是插入到方法结束处和异常处，虚拟机要保证每个`monitorenter`必须有对应的`monitorexit`与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到`monitorenter`指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。



<br>

---

**参考资料**

1. 《深入理解Java虚拟机：JVM高级特性与最佳实践》 周志明，机械工业出版社，第12章
2. 《Java并发编程的艺术》方腾飞，魏鹏，程晓明，机械工业出版社，第2章