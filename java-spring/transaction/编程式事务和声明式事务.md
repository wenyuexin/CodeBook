# 编程式事务和声明式事务

**编程式事务**

使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。

**声明式事务**

建立在AOP之上。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。

<br>

显然声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式。声明式事务管理使业务代码不受污染，一个普通的POJO对象，只要加上注解就可以获得完全的事务支持。**和编程式事务相比，声明式事务唯一不足地方是，它的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别**。但是即便有这样的需求，也存在很多变通的方法，比如，可以将需要进行事务管理的代码块独立为方法等等。

声明式事务管理也有两种常用的方式，一种是基于tx和aop名字空间的xml配置文件，另一种就是基于@Transactional注解。显然基于注解的方式更简单易用。

<br>

## 编程式事务

实际使用中很少通过编程来进行事务管理。这里展示一个例子：

```
...
@Service
public class ForumService1 {

    public ForumDao forumDao;
    public TransactionTemplate template;

    @Autowired  //通过AOP主动注入
    public void setTemplate(TransactionTemplate template) {
        this.template = template;
    }

    public void addForum(final Forum forum) {
        template.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                forumDao.addForum(forum); //需要在事务环境中执行的代码
            }
        });
    }
}
```

TransactionTemplate有两个主要的方法：

```
void setTransactionManager(PlatformTransactionManager transactionManager); //设置事务管理器
Object execute(TransactionCallback action);//在action回调接口中定义需要以事务方式组织的数据访问
```

TransactionCallback中只有一个方法：

```
Object doInTransaction(TransactionStatus status); //返回结果
```

也可以使用TransactionCallback的子接口TransactionCallbackWithoutResult。

<br>

---

**参考资料**

1.   [Spring的编程式事务和声明式事务 - 博客园](https://www.cnblogs.com/nnngu/p/8627662.html)
2.  《精通Spring 4.x 企业应用开发实战》陈雄化，电子工业出版社，第11章

